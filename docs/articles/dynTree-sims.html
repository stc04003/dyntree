<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Applying landmark analysis on a longitudinal data • dynTree</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Applying landmark analysis on a longitudinal data">
<meta property="og:description" content="dynTree">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">dynTree</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/dynTree-sims.html">Applying landmark analysis on a longitudinal data</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Applying landmark analysis on a longitudinal data</h1>
                        <h4 class="author">Sy Han (Steven) Chiou</h4>
            
            <h4 class="date">2020-11-05</h4>
      
      
      <div class="hidden name"><code>dynTree-sims.Rmd</code></div>

    </div>

    
    
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script><p>In this vignette, we first generate a simulated data with longitudinal measures then apply landmark analysis with package <code>dynTree</code> assming a fixed landmark time.</p>
<div id="simulated-data" class="section level2">
<h2 class="hasAnchor">
<a href="#simulated-data" class="anchor"></a>Simulated data</h2>
<p>Consider a survival model with 20 predictors, of which 10 are time-independent predictors and the other 10 are longitudinal predictors. Suppose the predictors were generated from the following description:</p>
<ul>
<li>The time-independent predictors <span class="math inline">\({{\mathbf Z}}= \{Z_1, \ldots, Z_{10}\}\)</span> are generated from a multivariate normal random variable with <span class="math inline">\(E(Z_i) = Var(Z_i) = 1\)</span>, and <span class="math inline">\(Cov(Z_i, Z_j) = 0.5^{|i - j|}\)</span>, for <span class="math inline">\(i, j = 1, \ldots, 10\)</span>.</li>
<li>The longitudinal predictors <span class="math inline">\({{\mathbf W}}(t) = \{W_1(t), \ldots, W_{10}(t)\}\)</span> were generated from <span class="math inline">\(W_i(t) = a_iF(b_it) / t\)</span> for <span class="math inline">\(i = 1, \ldots, 10\)</span>, where <span class="math inline">\(a_i\)</span> follows a uniform distribution on <span class="math inline">\([-1, 1]\)</span>, <span class="math inline">\(b_i\)</span> follows a standard uniform distribution, and <span class="math inline">\(F(x) = 1 - e^{-x^2}\)</span>.</li>
</ul>
<p>In a longitudinal setting, <span class="math inline">\({{\mathbf W}}(t)\)</span> are regularly measured at fixed time points, <span class="math inline">\(t_1&lt;\ldots &lt;t_k\)</span>. As time progresses, each <span class="math inline">\(t_k\)</span> can serve as a landmark time and predicting the event risk on the time interval <span class="math inline">\((t_k, t_{k + 1})\)</span> using predictors information observed up to <span class="math inline">\(t_k\)</span> would be of interest. That is, at the landmark time <span class="math inline">\(t_k\)</span>, we are interested in predicting <span class="math display">\[P\{T\ge t_k + t | T\ge t_k, {{\mathbf W}}(t_1), \ldots, {{\mathbf W}}(t_{k}), {{\mathbf Z}}\}\]</span> for <span class="math inline">\(0&lt;t&lt;t_{k + 1} - t_k\)</span> and <span class="math inline">\(k\ge1\)</span>. To illustrate the usage of the <code>dynTree</code> package on application like this, we generated the falure time <span class="math inline">\(T\)</span> based on the following hazard function, <span class="math display">\[\lambda\{t|{{\mathbf W}}(t), {{\mathbf Z}}\} = 1.6 I(t &gt; 1) + 0.5 \exp\left\{ \theta_1{{\mathbf W}}(t) + \theta_2{{\mathbf Z}}+ \theta_1\theta_2{{\mathbf W}}(t){{\mathbf Z}}\right\},\]</span> where <span class="math inline">\(\theta_1\)</span> and <span class="math inline">\(\theta_2\)</span> are the corresponding regression coefficients. The following functions <code>hz()</code> and <code>Hz()</code> specify the above hazard function given <span class="math inline">\(({{\mathbf Z}}, a, b)\)</span> and a numerical approximation of <span class="math inline">\(\Lambda(t) = \int_0^t \lambda\{u|{{\mathbf W}}(t), {{\mathbf Z}}\}\,du\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>hz &lt;-<span class="st"> </span>function(tt, a, b, z) {
+<span class="st">     </span>Wt &lt;-<span class="st"> </span>a *<span class="st"> </span><span class="kw">pweibull</span>(b *<span class="st"> </span>tt, <span class="dv">2</span>) /<span class="st"> </span>tt
+<span class="st">     </span><span class="fl">1.6</span> *<span class="st"> </span>(tt &gt;<span class="st"> </span><span class="dv">1</span>) +<span class="st"> </span>.<span class="dv">5</span> *<span class="st"> </span><span class="kw">exp</span>(<span class="kw">sum</span>(Wt) -<span class="st"> </span><span class="kw">sum</span>(z) +<span class="st"> </span><span class="kw">sum</span>(Wt *<span class="st"> </span>z))
+<span class="st"> </span>}
&gt;<span class="st"> </span>Hz &lt;-<span class="st"> </span>function(tt, a, b, z) {
+<span class="st">     </span><span class="kw">integrate</span>(<span class="dt">f =</span> function(y)
+<span class="st">         </span><span class="kw">sapply</span>(y, function(yy) <span class="kw">hz</span>(yy, <span class="dt">a =</span> a, <span class="dt">b =</span> b, <span class="dt">z =</span> z)),
+<span class="st">         </span><span class="dt">lower =</span> <span class="dv">0</span>, <span class="dt">upper =</span> tt, <span class="dt">subdivisions =</span> 500L)$value
+<span class="st"> </span>}</code></pre></div>
<p>The following function is used to generate failure time, <span class="math inline">\(Y\)</span>, based on inverse transform method.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>getY &lt;-<span class="st"> </span>function(a, b, z, u) {
+<span class="st">     </span>if (<span class="kw">exp</span>(-<span class="kw">Hz</span>(<span class="dv">10</span>, a, b, z)) &gt;<span class="st"> </span>u) <span class="kw">return</span>(<span class="fl">1e-3</span>)
+<span class="st">     </span><span class="kw">uniroot</span>(<span class="dt">f =</span> function(s) <span class="kw">exp</span>(-<span class="kw">Hz</span>(s, a, b, z)) -<span class="st"> </span>u, <span class="dt">interval =</span> <span class="kw">c</span>(<span class="fl">1e-7</span>, <span class="dv">10</span>))$root
+<span class="st"> </span>}</code></pre></div>
<p>We use the above functions to generate the failure time and predictors for one individual, then generalize the procedure to generate a larger data set. Assuming <span class="math inline">\(\theta_1 = (1, 1, 1, 1, 1, 0, 0, 0, 0, 0)^\top\)</span> and <span class="math inline">\(\theta_2 = (0, 0, 0, 0, 1, 1, 1, 1, 1, 0)^\top\)</span>, one draw of failure time under the above specification can be obtained by the following code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">library</span>(MASS)
&gt;<span class="st"> </span><span class="kw">set.seed</span>(<span class="dv">1</span>)
&gt;<span class="st"> </span>a &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">10</span>, -<span class="dv">1</span>, <span class="dv">1</span>)
&gt;<span class="st"> </span>b &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">10</span>)
&gt;<span class="st"> </span>z &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">mvrnorm</span>(<span class="dv">1</span>, <span class="kw">rep</span>(<span class="dv">1</span>, <span class="dv">10</span>), .<span class="dv">5</span>^<span class="kw">outer</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dv">1</span>:<span class="dv">10</span>, function(x, y) <span class="kw">abs</span>(x -<span class="st"> </span>y))), <span class="dv">1</span>)
&gt;<span class="st"> </span>u &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
&gt;<span class="st"> </span>(y &lt;-<span class="st"> </span><span class="kw">getY</span>(a[<span class="dv">1</span>:<span class="dv">5</span>], b[<span class="dv">1</span>:<span class="dv">5</span>], z[<span class="dv">5</span>:<span class="dv">9</span>], u))</code></pre></div>
<pre><code>[1] 1.035534</code></pre>
<p>A <code>data.frame</code> containing parameters <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(z\)</span>, and failure times, for <code>n</code> individuals can be constructed using the following function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>getDat &lt;-<span class="st"> </span>function(n) {
+<span class="st">     </span>z &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(n, <span class="kw">rep</span>(<span class="dv">1</span>, <span class="dv">10</span>), .<span class="dv">5</span>^<span class="kw">outer</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dv">1</span>:<span class="dv">10</span>, function(x, y) <span class="kw">abs</span>(x -<span class="st"> </span>y)))
+<span class="st">     </span>a &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(<span class="dv">10</span> *<span class="st"> </span>n, -<span class="dv">1</span>, <span class="dv">1</span>), n)
+<span class="st">     </span>b &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(<span class="dv">10</span> *<span class="st"> </span>n), n)
+<span class="st">     </span>y &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span>:n, function(x) <span class="kw">getY</span>(a[x, <span class="dv">1</span>:<span class="dv">5</span>], b[x, <span class="dv">1</span>:<span class="dv">5</span>], z[x, <span class="dv">5</span>:<span class="dv">9</span>], <span class="kw">runif</span>(<span class="dv">1</span>)))
+<span class="st">     </span>out &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">id =</span> <span class="dv">1</span>:n, <span class="dt">Time =</span> y, <span class="dt">z =</span> z, <span class="dt">a =</span> a, <span class="dt">b =</span> b)
+<span class="st">     </span><span class="kw">return</span>(out)
+<span class="st"> </span>}
&gt;<span class="st"> </span><span class="kw">set.seed</span>(<span class="dv">117</span>); dat &lt;-<span class="st"> </span><span class="kw">getDat</span>(<span class="dv">400</span>)
&gt;<span class="st"> </span><span class="kw">dim</span>(dat); <span class="kw">names</span>(dat)</code></pre></div>
<pre><code>[1] 400  32</code></pre>
<pre><code> [1] "id"   "Time" "z.1"  "z.2"  "z.3"  "z.4"  "z.5"  "z.6"  "z.7"  "z.8" 
[11] "z.9"  "z.10" "a.1"  "a.2"  "a.3"  "a.4"  "a.5"  "a.6"  "a.7"  "a.8" 
[21] "a.9"  "a.10" "b.1"  "b.2"  "b.3"  "b.4"  "b.5"  "b.6"  "b.7"  "b.8" 
[31] "b.9"  "b.10"</code></pre>
<p>Each row in <code>dat</code> represents information for one subject. The subject identifications are stored in column <code>id</code> and the failure times are stored in column <code>Time</code>. Time independent predictor are stored in columns <code>z.1</code> through <code>z.10</code>. The longitudinal predictors measured at landmark times <span class="math inline">\(t_k\)</span> can be calculated based on <code>a.1</code><span class="math inline">\(\ldots\)</span><code>a.10</code> and <code>b.1</code><span class="math inline">\(\ldots\)</span><code>b.10</code> given <span class="math inline">\(t_k\)</span>. Suppose the landmark times considered in this simulation study are <span class="math inline">\(t_1 = 1\)</span> and <span class="math inline">\(t_2 = 2\)</span>. The following code and figure depict the first four observed failure times in <code>dat</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">head</span>(dat$Time)</code></pre></div>
<pre><code>[1] 1.276556 1.630298 2.028023 3.527834 1.040375 2.303940</code></pre>
<div class="figure">
<img src="long.png">
</div>
<p>At <span class="math inline">\(t_1 = 1\)</span>, all available predictor information (colored in green) including <span class="math inline">\({{\mathbf Z}}\)</span> and <span class="math inline">\({{\mathbf W}}(t_1)\)</span> are used to predict the event risk <span class="math inline">\(P(T\ge t_1 + t|T\ge t_1, {{\mathbf W}}(t_1), {{\mathbf Z}})\)</span>. In the simulated data, all of the first four failure times are greater than <span class="math inline">\(t_1\)</span> so are included in the landmark analysis when landmark time is <span class="math inline">\(t_1\)</span>. However, subjects <code>id = 3</code> and <code>id = 4</code> experienced events (at time 2.028 and 3.528, respectively) after the second landmark time (<span class="math inline">\(t_2 = 2\)</span>) so the corresponding failure times are censored at <span class="math inline">\(t_2 = 2\)</span> when included in the analysis.</p>
<p>On the other hand, subjects <code>id = 1</code> and <code>id = 2</code> are excluded in the landmark model when the landmark is <span class="math inline">\(t_2\)</span> as their failure times are less than <span class="math inline">\(t_2\)</span>. At <span class="math inline">\(t_2 = 2\)</span>, additional longitudinal predictors become available for subjects <code>id = 3</code> and <code>id = 4</code>, e.g., <span class="math inline">\({{\mathbf W}}_3(t_2)\)</span> and <span class="math inline">\({{\mathbf W}}_4(t_2)\)</span>. Similar to the scenario when landmark is at <span class="math inline">\(t_1\)</span>, the failure time for subject <code>id = 4</code> is censored at <span class="math inline">\(t_3 = 3\)</span>.</p>
<p>The following code modifies the above <code>getDat()</code> function to accomdiate the administrative censoring induced by <span class="math inline">\(t_{k + 1}\)</span> and an additional independent right-censoring.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>getDat &lt;-<span class="st"> </span>function(n, cr, land) {
+<span class="st">     </span>z &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(n, <span class="kw">rep</span>(<span class="dv">1</span>, <span class="dv">10</span>), .<span class="dv">5</span>^<span class="kw">outer</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dv">1</span>:<span class="dv">10</span>, function(x, y) <span class="kw">abs</span>(x -<span class="st"> </span>y)))
+<span class="st">     </span>a &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(<span class="dv">10</span> *<span class="st"> </span>n, -<span class="dv">1</span>, <span class="dv">1</span>), n)
+<span class="st">     </span>b &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(<span class="dv">10</span> *<span class="st"> </span>n), n)
+<span class="st">     </span>y &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span>:n, function(x) <span class="kw">getY</span>(a[x, <span class="dv">1</span>:<span class="dv">5</span>], b[x, <span class="dv">1</span>:<span class="dv">5</span>], z[x, <span class="dv">5</span>:<span class="dv">9</span>], <span class="kw">runif</span>(<span class="dv">1</span>)))
+<span class="st">     </span>if (land ==<span class="st"> </span><span class="dv">1</span>) {
+<span class="st">         </span>if (cr ==<span class="st"> </span>.<span class="dv">2</span>) cc &lt;-<span class="st"> </span><span class="kw">runif</span>(n, <span class="dv">0</span>, <span class="fl">7.51</span>)
+<span class="st">         </span>if (cr ==<span class="st"> </span>.<span class="dv">4</span>) cc &lt;-<span class="st"> </span><span class="kw">runif</span>(n, <span class="dv">0</span>, <span class="fl">3.91</span>)
+<span class="st">     </span>}
+<span class="st">     </span>if (land ==<span class="st"> </span><span class="dv">2</span>) {
+<span class="st">         </span>if (cr ==<span class="st"> </span>.<span class="dv">2</span>) cc &lt;-<span class="st"> </span><span class="kw">runif</span>(n, <span class="dv">0</span>, <span class="fl">11.35</span>)
+<span class="st">         </span>if (cr ==<span class="st"> </span>.<span class="dv">4</span>) cc &lt;-<span class="st"> </span><span class="kw">runif</span>(n, <span class="dv">0</span>, <span class="fl">5.68</span>)   
+<span class="st">     </span>}
+<span class="st">     </span>out &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">id =</span> <span class="dv">1</span>:n, <span class="dt">Time =</span> <span class="kw">pmin</span>(y, cc, land +<span class="st"> </span><span class="dv">1</span>), <span class="dt">delta =</span> <span class="dv">1</span> *<span class="st"> </span>(y &lt;=<span class="st"> </span><span class="kw">pmin</span>(cc, <span class="dv">2</span>)),
+<span class="st">                       </span><span class="dt">z =</span> z, <span class="dt">w1 =</span> a *<span class="st"> </span><span class="kw">pweibull</span>(b, <span class="dv">2</span>))
+<span class="st">     </span>if (land ==<span class="st"> </span><span class="dv">2</span>) out$w2 &lt;-<span class="st"> </span>a *<span class="st"> </span><span class="kw">pweibull</span>(b *<span class="st"> </span><span class="dv">2</span>, <span class="dv">2</span>) /<span class="st"> </span><span class="dv">2</span>
+<span class="st">     </span>out$a &lt;-<span class="st"> </span>a
+<span class="st">     </span>out$b &lt;-<span class="st"> </span>b
+<span class="st">     </span><span class="kw">return</span>(<span class="kw">subset</span>(out, Time &gt;<span class="st"> </span>land))
+<span class="st"> </span>}
&gt;<span class="st"> </span><span class="kw">set.seed</span>(<span class="dv">117</span>); dat1 &lt;-<span class="st"> </span><span class="kw">getDat</span>(<span class="dv">400</span>, .<span class="dv">2</span>, <span class="dv">1</span>)
&gt;<span class="st"> </span><span class="kw">set.seed</span>(<span class="dv">117</span>); dat2 &lt;-<span class="st"> </span><span class="kw">getDat</span>(<span class="dv">400</span>, .<span class="dv">2</span>, <span class="dv">2</span>)
&gt;<span class="st"> </span><span class="kw">names</span>(dat1)</code></pre></div>
<pre><code> [1] "id"    "Time"  "delta" "z.1"   "z.2"   "z.3"   "z.4"   "z.5"   "z.6"  
[10] "z.7"   "z.8"   "z.9"   "z.10"  "w1.1"  "w1.2"  "w1.3"  "w1.4"  "w1.5" 
[19] "w1.6"  "w1.7"  "w1.8"  "w1.9"  "w1.10" "a"     "b"    </code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">head</span>(dat1$Time)</code></pre></div>
<pre><code>[1] 1.276556 1.630298 2.000000 2.000000 1.040375 2.000000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">head</span>(dat2$Time)</code></pre></div>
<pre><code>[1] 2.028023 3.000000 2.303940 3.000000 2.159132 2.240095</code></pre>
<p>The modified <code>getDat()</code> takes three arguments; <code>n</code> for sample size, <code>cr</code> for censoring rate, and <code>land</code> for the fixed landmark time. The available values for <code>cr</code> is 0.2 and 0.4 while the available values for <code>land</code> are 1 and 2. The censoring time was generated from a uniform distribution on <span class="math inline">\([0, c]\)</span>, where <span class="math inline">\(c\)</span> was chosen to achieve either a 20% or 40% rate of censoring, i.e., the average proportion of failure times censored by whether the administrative censoring of <span class="math inline">\(t_k + 1\)</span> or random censoring.</p>
<p>The <code>getDat()</code> returns a <code>data.frame</code> consists of subjects with an observed survival time greater than the landmark time. The observed survival time is stored in column <code>Time</code> with the corresponding censoring indicator in column <code>delta</code> (<code>delta = 1</code> if uncensored, <code>delta = 0</code> otherwise). Time-independent predictors are stored in columns <code>z.1</code> through <code>z.10</code> and longitudinal predictors measured at <span class="math inline">\(t_1\)</span> is stored in columns <code>w1.1</code> through <code>w1.10</code>. When the landmark is <span class="math inline">\(t_2 = 2\)</span>, longitudinal predictors measured at <span class="math inline">\(t_2\)</span> is stored in columns <code>w2.1</code> through <code>w2.10</code>. Although not used in fitting the landmark model, variables <code>a</code> and <code>b</code> will be used to calculate the true survival probability to assess the performance of the proposed landmark model.</p>
</div>
<div id="the-dyntree-function" class="section level2">
<h2 class="hasAnchor">
<a href="#the-dyntree-function" class="anchor"></a>The <code>dynTree</code> function</h2>
<p>The <code>dynTree</code> package can be installed and load with the following commands:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>devtools::<span class="kw">install_github</span>(<span class="st">"stc04003/dynTree"</span>)
&gt;<span class="st"> </span><span class="kw">library</span>(dynTree)</code></pre></div>
<p>The main function in the <code>dynTree</code> package is <code><a href="../reference/dynTree.html">dynTree()</a></code>, with the following arguments</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">args</span>(dynTree)</code></pre></div>
<pre><code>function (formula, data, id, subset, ensemble = TRUE, groups = NULL, 
    trans = TRUE, control = list()) 
NULL</code></pre>
<p>The arguments are as follows</p>
<ul>
<li>
<code>formula</code> is a formula object, with the response on the left of a <code><a href="https://rdrr.io/r/base/tilde.html">~</a></code> operator, and the predictors on the right. The response must be a survival object returned by the function <code>Surv</code> from the <code>survival</code> package.</li>
<li>
<code>data</code> is an optional data frame to interpret the variables occurring in the <code>formula</code>.</li>
<li>
<code>id</code> is an optional vector used to identify the longitudinal observations of subject's id.</li>
<li>
<code>subset</code> is an optional vector specifying a subset of observations to be used in the fitting process.</li>
<li>
<code>ensemble</code> is an optional logical value. If <code>TRUE</code> (default), ensemble methods will be fitted. Otherwise, the survival tree will be fitted.</li>
<li>
<code>group</code> is an optional vector with the length equal to the number of covariates. This vector indicates the covariates to be splitted together in the emsemble method.</li>
<li>
<code>trans</code> indicates whether to perform time-dependent transformation when each row represents an observation. See <span class="citation">Sun, Chiou, and Wang (2019)</span> for more details about the time-dependent transformation.</li>
<li>
<code>control</code> is a list of control parameters.</li>
</ul>
<p>The argument <code>control</code> defaults to a list with the following values:</p>
<ul>
<li>
<code>tau</code> is the maximum follow-up time; default value is the 90th percentile of the unique observed survival times.</li>
<li>
<code>maxNode</code> is the maximum node number allowed to be in the tree; the default value is <code>500</code>.</li>
<li>
<code>numFold</code> is the number of folds used in the cross-validation. When <code>numFold &gt; 0</code>, the survival tree will be pruned; when <code>numFold = 0</code>, the unpruned survival tree will be presented. The default value is <code>10</code>.</li>
<li>
<code>h</code> is the smoothing parameter used in the Kernel; the default value is <code>tau / 20</code>.</li>
<li>
<code>minSplitTerm</code> is the minimum number of baseline observations in each terminal node; the default value is <code>15</code>.</li>
<li>
<code>minSplitNode</code> is the minimum number of baseline observations in each splitable node; the default value is <code>30</code>.</li>
<li>
<code>disc</code> is a logical vector specifying whether the covariates in <code>formula</code> are discrete (<code>TRUE</code>) or continuous (<code>FALSE</code>). The length of <code>disc</code> should be the same as the number of covariates in <code>formula</code>. When not specified, the <code>rocTree()</code> function assumes continuous covariates for all.</li>
<li>
<code>K</code> is the number of time points on which the concordance measure is computed. A less refined time grids (smaller <code>K</code>) generally yields faster speed but a very small <code>K</code> is not recommended. The default value is 20.</li>
</ul>
</div>
<div id="fitting-dyntree" class="section level2">
<h2 class="hasAnchor">
<a href="#fitting-dyntree" class="anchor"></a>Fitting <code>dynTree</code>
</h2>
<p>We demonstrate the useage of <code><a href="../reference/dynTree.html">dynTree()</a></code> with the simulated data, <code>dat1</code>. Since the prediction is in <span class="math inline">\(t\in[t_k, t_{k + 1}]\)</span>, we define <code>Time2</code> as the time beyond landmark time.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>dat1$Time2 &lt;-<span class="st"> </span>dat1$Time -<span class="st"> </span><span class="dv">1</span></code></pre></div>
<p>Since the argument <code>numFold</code> controls the number of cross-validation in pruning, the fully grown (un-pruned) survival tree can be constructed as follow:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>(fit1 &lt;-<span class="st"> </span><span class="kw">dynTree</span>(<span class="kw">Surv</span>(Time2, delta) ~<span class="st"> </span>., <span class="dt">id =</span> id, <span class="dt">data =</span> <span class="kw">subset</span>(dat1, <span class="dt">select =</span> -<span class="kw">c</span>(a, b, Time)), 
+<span class="st">                  </span><span class="dt">ensemble =</span> <span class="ot">FALSE</span>, <span class="dt">trans =</span> <span class="ot">TRUE</span>, <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">numFold =</span> <span class="dv">0</span>)))</code></pre></div>
<pre><code> Survival tree

 node), split
   * denotes terminal node
  
Root                                            
 ¦--2) z.7 &lt;= 0.74627                           
 ¦   ¦--4) z.10 &lt;= 0.56219                      
 ¦   ¦   ¦--8) z.4 &lt;= 0.86070                   
 ¦   ¦   ¦   ¦--16) w1.2 &lt;= 0.77612             
 ¦   ¦   ¦   ¦   ¦--32) z.1 &lt;= 0.60697          
 ¦   ¦   ¦   ¦   ¦   ¦--64) z.1 &lt;= 0.39801      
 ¦   ¦   ¦   ¦   ¦   ¦   ¦--128) z.7 &lt;= 0.49751*
 ¦   ¦   ¦   ¦   ¦   ¦   °--129) z.7 &gt; 0.49751* 
 ¦   ¦   ¦   ¦   ¦   °--65) z.1 &gt; 0.39801*      
 ¦   ¦   ¦   ¦   °--33) z.1 &gt; 0.60697           
 ¦   ¦   ¦   ¦       ¦--66) z.2 &lt;= 0.59701*     
 ¦   ¦   ¦   ¦       °--67) z.2 &gt; 0.59701*      
 ¦   ¦   ¦   °--17) w1.2 &gt; 0.77612*             
 ¦   ¦   °--9) z.4 &gt; 0.86070*                   
 ¦   °--5) z.10 &gt; 0.56219                       
 ¦       ¦--10) w1.9 &lt;= 0.67662                 
 ¦       ¦   ¦--20) w1.9 &lt;= 0.14428*            
 ¦       ¦   °--21) w1.9 &gt; 0.14428              
 ¦       ¦       ¦--42) z.4 &lt;= 0.42786*         
 ¦       ¦       °--43) z.4 &gt; 0.42786*          
 ¦       °--11) w1.9 &gt; 0.67662                  
 ¦           ¦--22) w1.1 &lt;= 0.52239*            
 ¦           °--23) w1.1 &gt; 0.52239*             
 °--3) z.7 &gt; 0.74627                            
     ¦--6) z.9 &lt;= 0.30348*                      
     °--7) z.9 &gt; 0.30348                        
         ¦--14) z.2 &lt;= 0.19900*                 
         °--15) z.2 &gt; 0.19900                   
             ¦--30) z.1 &lt;= 0.42786*             
             °--31) z.1 &gt; 0.42786               
                 ¦--62) z.3 &lt;= 0.63682*         
                 °--63) z.3 &gt; 0.63682*          </code></pre>
<p>A pruned tree can be constructed as follow:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>(fit2 &lt;-<span class="st"> </span><span class="kw">dynTree</span>(<span class="kw">Surv</span>(Time2, delta) ~<span class="st"> </span>., <span class="dt">id =</span> id, <span class="dt">data =</span> <span class="kw">subset</span>(dat1, <span class="dt">select =</span> -<span class="kw">c</span>(a, b, Time)), 
+<span class="st">                  </span><span class="dt">ensemble =</span> <span class="ot">FALSE</span>, <span class="dt">trans =</span> <span class="ot">TRUE</span>))</code></pre></div>
<pre><code> Survival tree

 node), split
   * denotes terminal node
  
Root                                
 ¦--2) z.7 &lt;= 0.74627               
 ¦   ¦--4) z.10 &lt;= 0.56219          
 ¦   ¦   ¦--8) z.4 &lt;= 0.86070       
 ¦   ¦   ¦   ¦--16) w1.2 &lt;= 0.77612*
 ¦   ¦   ¦   °--17) w1.2 &gt; 0.77612* 
 ¦   ¦   °--9) z.4 &gt; 0.86070*       
 ¦   °--5) z.10 &gt; 0.56219           
 ¦       ¦--10) w1.9 &lt;= 0.67662     
 ¦       ¦   ¦--20) w1.9 &lt;= 0.14428*
 ¦       ¦   °--21) w1.9 &gt; 0.14428* 
 ¦       °--11) w1.9 &gt; 0.67662      
 ¦           ¦--22) w1.1 &lt;= 0.52239*
 ¦           °--23) w1.1 &gt; 0.52239* 
 °--3) z.7 &gt; 0.74627                
     ¦--6) z.9 &lt;= 0.30348*          
     °--7) z.9 &gt; 0.30348            
         ¦--14) z.2 &lt;= 0.19900*     
         °--15) z.2 &gt; 0.19900*      </code></pre>
<p>Lastly, turning <code>ensemble = TRUE</code> applies the ensemble method:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>(fit3 &lt;-<span class="st"> </span><span class="kw">dynTree</span>(<span class="kw">Surv</span>(Time2, delta) ~<span class="st"> </span>., <span class="dt">id =</span> id, <span class="dt">data =</span> <span class="kw">subset</span>(dat1, <span class="dt">select =</span> -<span class="kw">c</span>(a, b, Time)), 
+<span class="st">                  </span><span class="dt">ensemble =</span> <span class="ot">TRUE</span>, <span class="dt">trans =</span> <span class="ot">TRUE</span>))</code></pre></div>
<pre><code>Ensembles

Call:
 dynTree(formula = Surv(Time2, delta) ~ ., data = subset(dat1,      select = -c(a, b, Time)), id = id, ensemble = TRUE, trans = TRUE) 

Sample size:                                        
Number of independent variables:                    325 
Number of trees:                                    500 
Number of variables tried at each split:            5 
Number of time points to evaluate CON:              20 
Min. number of baseline obs. in a splittable node:  30 
Min. number of baseline obs. in a terminal node:    15 </code></pre>
</div>
<div id="model-performance" class="section level2">
<h2 class="hasAnchor">
<a href="#model-performance" class="anchor"></a>Model performance</h2>
<p>To assess the performance of the proposed methods, we independently generate a test data with <code>n = 500</code> under the same setting.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">set.seed</span>(<span class="dv">1</span>); datTest &lt;-<span class="st"> </span><span class="kw">getDat</span>(<span class="dv">500</span>, .<span class="dv">2</span>, <span class="dv">1</span>); datTest$Time2 &lt;-<span class="st"> </span>datTest$Time -<span class="st"> </span><span class="dv">1</span></code></pre></div>
<p>The predicted probability can be obtained by applying the generic function <code><a href="https://rdrr.io/r/stats/predict.html">predict()</a></code> to each subjects in the test data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>pred1 &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(datTest), function(x) <span class="kw">predict</span>(fit1, datTest[x,])$survFun) 
&gt;<span class="st"> </span>pred2 &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(datTest), function(x) <span class="kw">predict</span>(fit2, datTest[x,])$survFun)
&gt;<span class="st"> </span>pred3 &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(datTest), function(x) <span class="kw">predict</span>(fit3, datTest[x,])$survFun)</code></pre></div>
<p>We use the following codes to calculate the true survival probability for each subject in the test data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>trSiFun &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(datTest), function(s) {
+<span class="st">     </span>tmp =<span class="st"> </span>datTest[s,]
+<span class="st">     </span>g0 =<span class="st"> </span><span class="kw">seq</span>(<span class="fl">1e-5</span>, <span class="dv">2</span>, <span class="fl">1e-2</span>)
+<span class="st">     </span>a0 =<span class="st"> </span><span class="kw">as.numeric</span>(tmp$a[<span class="dv">1</span>:<span class="dv">5</span>])
+<span class="st">     </span>b0 =<span class="st"> </span><span class="kw">as.numeric</span>(tmp$b[<span class="dv">1</span>:<span class="dv">5</span>])
+<span class="st">     </span>z0 =<span class="st"> </span><span class="kw">as.numeric</span>(tmp$z[<span class="dv">1</span>:<span class="dv">5</span>])
+<span class="st">     </span>tmpS =<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">sapply</span>(g0, function(tt) <span class="kw">exp</span>(-<span class="kw">Hz</span>(tt, a0, b0, z0))))
+<span class="st">     </span><span class="kw">return</span>(function(t2)
+<span class="st">         </span><span class="kw">stepfun</span>(<span class="dt">x =</span> g0, <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">1</span>, tmpS))(t2 +<span class="st"> </span><span class="dv">1</span>) /<span class="st"> </span><span class="kw">stepfun</span>(<span class="dt">x =</span> g0, <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">1</span>, tmpS))(<span class="dv">1</span>))})</code></pre></div>
<p>One way to assess the performance of the proposed model is to compare the estimated survival with the truth. In the following code, we compare the square of the difference between the predicted probability and true probability at 50 evenly spaced points between 0 and the 90th percentile of the observed failure time in the test data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>t0 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>, <span class="kw">quantile</span>(datTest$Time2, .<span class="dv">9</span>), <span class="dt">length.out =</span> <span class="dv">50</span>)
&gt;<span class="st"> </span>err1 &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span>:<span class="kw">length</span>(pred1), function(x) (pred1[[x]](t0) -<span class="st"> </span>trSiFun[[x]](t0))^<span class="dv">2</span>)
&gt;<span class="st"> </span>err2 &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span>:<span class="kw">length</span>(pred1), function(x) (pred2[[x]](t0) -<span class="st"> </span>trSiFun[[x]](t0))^<span class="dv">2</span>)
&gt;<span class="st"> </span>err3 &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span>:<span class="kw">length</span>(pred1), function(x) (pred3[[x]](t0) -<span class="st"> </span>trSiFun[[x]](t0))^<span class="dv">2</span>)
&gt;<span class="st"> </span><span class="kw">mean</span>(err1)</code></pre></div>
<pre><code>[1] 0.04541641</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">mean</span>(err2)</code></pre></div>
<pre><code>[1] 0.02969028</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">mean</span>(err3)</code></pre></div>
<pre><code>[1] 0.005586071</code></pre>
<p>The ensemble method yields the smallest squared error, followed by the pruned tree.</p>
</div>
<div id="reference" class="section level2 unnumbered">
<h2 class="hasAnchor">
<a href="#reference" class="anchor"></a>Reference</h2>
<div id="refs" class="references">
<div id="ref-sun2019roc">
<p>Sun, Yifei, Sy Han Chiou, and Mei-Cheng Wang. 2019. “ROC-Guided Survival Trees and Ensembles.” <em>Biometrics</em>. Wiley Online Library.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Yifei Sun, Sy Han Chiou.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
